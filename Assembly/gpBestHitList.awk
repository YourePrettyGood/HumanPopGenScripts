#!/bin/awk -f
#This script takes the .gp script generated by mummerplot, plus the output
# of BEDbestHit.awk to filter, reorder, and reorient contigs for the
# final dotplot.
#We filter contigs such that they need to map to a major chromosome (not
# alts, unplaced scaffolds, or decoys), and they need to show a minimum
# alignment coverage (i.e. query coverage), which is 80% by default.
#Set this minimum coverage threshold with the mincov argument.
#I also added a minimum aligned length filter to avoid too much
# overplotting. This is set with the minlen argument, and defaults to
# 100000.
#The output is a tab-separated file with columns:
# 1) Contig ID
# 2) Best hit chromosome ID
# 3) Index in the input .gp file's y-axis tick label list
# 4) Orientation in the input .gp file
# 5) Orientation inferred by BEDbestHit.awk
#This output can then be sorted (sort -k2,2V -k3,3n) and processed along
# with the .fai of the assembly to generate the contig and chromosome
# order file needed by mummerplot -Q and -R.
#2024/09/06: Added a way to omit the .gp and still output order, although
# the value in the 3rd column of the output is then only partially ordered.
# Specify -v "order=infer" for this, and pass <(echo "") for the .gp if
# you don't have one.
BEGIN{
   OFS="\t";
   filenum=0;
   if (length(mincov) == 0) {
      mincov=80.0;
   };
   if (length(minlen) == 0) {
      minlen=100000;
   };
   if (length(order) == 0) {
      order="gp";
   };
   if (order != "infer" && order != "gp") {
      print "Unknown order value "order > "/dev/stderr";
      exit 2;
   };
}
FNR==1{
   filenum++;
}
#Ignore the rest of the .gp file after the ytics section:
filenum==1&&/""/{
   readin=0;
}
#Capture orientation and order of contigs from the ytics section:
filenum==1&&readin==1{
   gsub(/"/, "", $1);
   if (substr($1, 1, 1) == "*") {
      strand="-";
      $1=substr($1, 2);
   } else {
      strand="+";
   };
   ctgorder[$1]=++nctgs;
   ctgstrand[$1]=strand;
}
#Start reading after the "set ytics" line:
filenum==1&&/ytics/{
   readin=1;
}
#Read in column names of the output of BEDbestHits.awk:
filenum==2&&FNR==1{
   for (i=1; i<=NF; i++) {
      cols[$i]=i;
   };
}
#Store the best hit chromosome and inferred strand after filtering:
filenum==2&&FNR>1{
   #The output of BEDbestHit.awk is sorted in decreasing order of
   # total aligned length, so the first line for a given query-ref
   # pair is the best hit.
   if (!($cols["Query"] in ctgchrom) && $cols["QueryCov"] >= mincov && $cols["AlnRefLen"] >= minlen && $cols["Reference"] !~ "_") {
      ctgchrom[$cols["Query"]]=$cols["Reference"];
      ctginfstrand[$cols["Query"]]=$cols["Strand"];
      ctgalnstart[$cols["Query"]]=$cols["AlnStart"];
   };
}
END{
   #As a rough way to infer order without the .gp, we can use the start
   # coordinates of the alignments and just sort that array by value,
   # assigning integer indices. Note that this is only a partial ordering,
   # as we don't also stratify/sort by chromosome. This isn't important,
   # since we indicate to post-process with sort -k2,2V -k3,3n, and this
   # will fix the ordering.
   PROCINFO["sorted_in"]="@val_num_asc";
   i=1;
   for (ctg in ctgalnstart) {
      ctginforder[ctg]=i;
      i+=1;
   };
   #Sadly, awk doesn't have a built-in version sorting order, so we just
   # output the contigs in lexicographical order.
   #You can do a proper sort afterwards with sort -k2,2V -k3,3n
   PROCINFO["sorted_in"]="@ind_str_asc";
   for (ctg in ctgchrom) {
      if (order == "gp") {
         print ctg, ctgchrom[ctg], ctgorder[ctg], ctgstrand[ctg], ctginfstrand[ctg];
      } else {
         print ctg, ctgchrom[ctg], ctginforder[ctg], ctgstrand[ctg], ctginfstrand[ctg];
      };
   };
}
