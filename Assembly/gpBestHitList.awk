#!/bin/awk -f
#This script takes the .gp script generated by mummerplot, plus the output
# of BEDbestHit.awk to filter, reorder, and reorient contigs for the
# final dotplot.
#We filter contigs such that they need to map to a major chromosome (not
# alts, unplaced scaffolds, or decoys), and they need to show a minimum
# alignment coverage (i.e. query coverage), which is 80% by default.
#Set this minimum coverage threshold with the mincov argument.
#I also added a minimum aligned length filter to avoid too much
# overplotting. This is set with the minlen argument, and defaults to
# 100000.
#The output is a tab-separated file with columns:
# 1) Contig ID
# 2) Best hit chromosome ID
# 3) Index in the input .gp file's y-axis tick label list
# 4) Orientation in the input .gp file
# 5) Orientation inferred by BEDbestHit.awk
#This output can then be sorted (sort -k2,2V -k3,3n) and processed along
# with the .fai of the assembly to generate the contig and chromosome
# order file needed by mummerplot -Q and -R.
BEGIN{
   OFS="\t";
   filenum=0;
   if (length(mincov) == 0) {
      mincov=80.0;
   };
   if (length(minlen) == 0) {
      minlen=100000;
   };
}
FNR==1{
   filenum++;
}
#Ignore the rest of the .gp file after the ytics section:
filenum==1&&/""/{
   readin=0;
}
#Capture orientation and order of contigs from the ytics section:
filenum==1&&readin==1{
   gsub(/"/, "", $1);
   if (substr($1, 1, 1) == "*") {
      strand="-";
      $1=substr($1, 2);
   } else {
      strand="+";
   };
   ctgorder[$1]=++nctgs;
   ctgstrand[$1]=strand;
}
#Start reading after the "set ytics" line:
filenum==1&&/ytics/{
   readin=1;
}
#Read in column names of the output of BEDbestHits.awk:
filenum==2&&FNR==1{
   for (i=1; i<=NF; i++) {
      cols[$i]=i;
   };
}
#Store the best hit chromosome and inferred strand after filtering:
filenum==2&&FNR>1{
   #The output of BEDbestHit.awk is sorted in decreasing order of
   # total aligned length, so the first line for a given query-ref
   # pair is the best hit.
   if (!($cols["Query"] in ctgchrom) && $cols["QueryCov"] >= mincov && $cols["AlnRefLen"] >= minlen && $cols["Reference"] !~ "_") {
      ctgchrom[$cols["Query"]]=$cols["Reference"];
      ctginfstrand[$cols["Query"]]=$cols["Strand"];
   };
}
END{
   #Sadly, awk doesn't have a built-in version sorting order, so we just
   # output the contigs in lexicographical order.
   #You can do a proper sort afterwards with sort -k2,2V -k3,3n
   PROCINFO["sorted_in"]="@ind_str_asc";
   for (ctg in ctgchrom) {
      print ctg, ctgchrom[ctg], ctgorder[ctg], ctgstrand[ctg], ctginfstrand[ctg];
   };
}
