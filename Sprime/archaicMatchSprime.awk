#!/bin/awk -f
#This script annotates the sites identified by Sprime (i.e. in the .score file)
# with columns for matches, mismatches, or absence from the genotypes of
# archaic individuals and groups.
#The inputs (in order) are:
# 1) A metadata file indicating which samples belong to which archaic group
#    Note: The metadata file must have a header that includes columns named
#     Sample and Region, where Sample is the sample ID, and Region is the
#     group (e.g. Neandertal, Denisovan)
# 2) VCF records corresponding *only* to the sites identified by Sprime for
#    the archaic samples of interest
# 3) The Sprime .score file
#For now, we hard-code both the expected column names and the expected
# archaic group names ("Neandertal" and "Denisovan"), as well as the archaic
# matching part (inasmuch as we expect 3 Neandertals and 1 Denisovan with
# particular sample IDs: AltaiNeandertal, Vindija33.19, Chagyrskaya-Phalanx,
# and Denisovan
#Options:
# spop: (required)   Name of the Sprime target population (i.e. not the outgroup)
#                    This value is only used to make a unique Tract ID column.
# gtfmt:(optional)   File format of the source of the archaic genotypes
#                    Possible values: "vcf", "query" (default: vcf)
# groups: (optional) Comma-separated list of archaic hominin groups to check
#                    Default: Denisovan,Neandertal
# arcs: (optional)   Comma-separated list of IDs of the archaics to check
#                    Default: AltaiNeandertal,Vindija33.19,Chagyrskaya-Phalanx
# short: (optional)  Comma-separated list of short names of the archaics to check
#                    Default: Altai,Vindija,Chagyrskaya
BEGIN{
   FS="\t";
   OFS=FS;
   if (length(spop) == 0) {
      print "spop variable is missing, please set it." > "/dev/stderr";
      print "spop is the name of the Sprime target population" > "/dev/stderr";
      print "i.e. the non-outgroup population in the Sprime run" > "/dev/stderr";
      print "It is used as a prefix for a unique tract identifier" > "/dev/stderr";
      exit 2;
   };
   if (length(gtfmt) == 0 || gtfmt != "query") {
      gtfmt="vcf";
   };
   if (length(groups) == 0) {
      groups="Neandertal,Denisovan";
   };
   n_arcgroups=split(groups, arcgroups, ",");
   if (length(arcs) == 0) {
      arcs="AltaiNeandertal,Vindija33.19,Chagyrskaya-Phalanx";
   };
   n_arcs=split(arcs, arcindivs, ",");
   if (length(short) == 0) {
      short="Altai,Vindija,Chagyrskaya";
   };
   n_short=split(short, arcshortnames, ",");
   if (n_arcs != n_short) {
      print "Number of archaic hominin samples to check (length of list arcs) does not match number of short names for them (length of list short). Quitting." >> "/dev/stderr";
      exit 3;
   };
   #Keep track of which file we're on:
   filenum=0;
   #Output order:
   PROCINFO["sorted_in"]="@ind_num_asc";
}
#Keep track of which file we're on:
FNR==1{
   filenum++;
}
#Keep track of processing time and metadata column names:
filenum==1&&FNR==1{
   f1start=systime();
   for (i=1; i<=NF; i++) {
      metacols[$i]=i;
   };
}
#Make a map from archaic hominin sample IDs to archaic hominin groups:
filenum==1&&FNR>1{
   region[$metacols["Sample"]]=$metacols["Region"];
}
#If the second file is generated by bcftools query, make sure to run
# with -H and -f '%CHROM:%POS[\t%TGT]\n'
filenum==2&&/^#( \[1])?CHROM/{
   f2start=systime();
   print "Processing archaic metadata file took "f2start-f1start" seconds" > "/dev/stderr";
   #Map the VCF/query sample columns to their archaic hominin IDs and groups:
   if (gtfmt == "query") {
      for (i=2; i<=NF; i++) {
         sub("[[0-9]+]", "", $i);
         sub(":GT", "", $i);
         for (j=1; j<=n_arcgroups; j++) {
            if (region[$i] == arcgroups[j]) {
               useindiv[i]=region[$i];
               indiv[i]=$i;
            };
         };
#         if (region[$i] == "Denisovan" || region[$i] == "Neandertal") {
#            useindiv[i]=region[$i];
#            indiv[i]=$i;
#         };
      };
   } else {
      for (i=10; i<=NF; i++) {
         for (j=1; j<=n_arcgroups; j++) {
            if (region[$i] == arcgroups[j]) {
               useindiv[i]=region[$i];
               indiv[i]=$i;
            };
         };
#         if (region[$i] == "Denisovan" || region[$i] == "Neandertal") {
#            useindiv[i]=region[$i];
#            indiv[i]=$i;
#         };
      };
   };
}
filenum==2&&!/^#/{
   n_vcf_records++;
   #Store the alleles found in count form for the different archaic hominins at each site:
   if (gtfmt == "query") {
      sitekey=$1;
      for (i in useindiv) {
         ploidy=split($i, tgt, "[/|]");
         for (j=1; j<=ploidy; j++) {
            if (tgt[j] == ".") {
               continue;
            };
            if (!((useindiv[i],tgt[j]) in AC)) {
               if ((sitekey,useindiv[i]) in arcalleles) {
                  arcalleles[sitekey,useindiv[i]]=arcalleles[sitekey,useindiv[i]]","tgt[j];
               } else {
                  arcalleles[sitekey,useindiv[i]]=tgt[j];
               };
            };
            AC[useindiv[i],tgt[j]]++;
            if (!((indiv[i],tgt[j]) in AC)) {
               if ((sitekey,indiv[i]) in arcalleles) {
                  arcalleles[sitekey,indiv[i]]=arcalleles[sitekey,indiv[i]]","tgt[j];
               } else {
                  arcalleles[sitekey,indiv[i]]=tgt[j];
               };
            };
            AC[indiv[i],tgt[j]]++;
         };
      };
      delete AC;
   } else {
      n_alts=split($5, alleles, ",");
      alleles[0]=$4;
      sitekey=$1":"$2;
      split($9, format, ":");
      for (f in format) {
         if (format[f] == "GT") {
            gtindex=f;
            break;
         };
      };
      for (i in useindiv) {
         split($i, samplearr, ":");
         ploidy=split(samplearr[gtindex], gt, "[/|]");
         for (j=1; j<=ploidy; j++) {
            if (gt[j] == ".") {
               continue;
            };
            if (!((useindiv[i],alleles[gt[j]]) in AC)) {
               if ((sitekey,useindiv[i]) in arcalleles) {
                  arcalleles[sitekey,useindiv[i]]=arcalleles[sitekey,useindiv[i]]","alleles[gt[j]];
               } else {
                  arcalleles[sitekey,useindiv[i]]=alleles[gt[j]];
               };
            };
            AC[useindiv[i],alleles[gt[j]]]++;
            if (!((indiv[i],alleles[gt[j]]) in AC)) {
               if ((sitekey,indiv[i]) in arcalleles) {
                  arcalleles[sitekey,indiv[i]]=arcalleles[sitekey,indiv[i]]","alleles[gt[j]];
               } else {
                  arcalleles[sitekey,indiv[i]]=alleles[gt[j]];
               };
            };
            AC[indiv[i],alleles[gt[j]]]++;
         };
      };
      delete AC;
   };
}
filenum==3&&FNR==1{
   f3start=systime();
   print "Processing archaic VCF took "f3start-f2start" seconds, average "(f3start-f2start)/n_vcf_records" seconds per record" > "/dev/stderr";
   #Store the column names from the Sprime .score file:
   for (i=1; i<=NF; i++) {
      sprimecols[$i]=i;
   };
   #Compose the extra column names for the output:
   archeader="TractID";
   for (i=1; i<=n_arcgroups; i++) {
      archeader=archeader OFS arcgroups[i]"Match";
   };
   for (i=1; i<=n_arcgroups; i++) {
      archeader=archeader OFS arcgroups[i]"Alleles";
   };
   for (i=1; i<=n_short; i++) {
      archeader=archeader OFS arcshortnames[i]"Match";
   };
   print $0, archeader;
#   print $0, "TractID", "NeandertalMatch", "DenisovanMatch", "NeandertalAlleles", "DenisovanAlleles", "AltaiMatch", "VindijaMatch", "ChagyrskayaMatch";
}
filenum==3&&FNR>1{
   n_score_records++;
   #Match the Sprime allele at a given site in a tract to the archaic hominins to detect matches, mismatches, or missingness:
   tractid=spop"_"$sprimecols["CHROM"]"_"$sprimecols["SEGMENT"];
   sitekey=$sprimecols["CHROM"]":"$sprimecols["POS"];
   split($sprimecols["ALT"], alleles, ",");
   alleles[0]=$sprimecols["REF"];
   sprimeallele=alleles[$sprimecols["ALLELE"]];
   #Do group-level matching and keep track of the set of alleles present across multiple samples in a group:
   for (i=1; i<=n_arcgroups; i++) {
      groupstate[arcgroups[i]]="missing";
      groupallelestr[arcgroups[i]]="Unk";
      if ((sitekey,arcgroups[i]) in arcalleles) {
         groupstate[arcgroups[i]]="mismatch";
         groupallelestr[arcgroups[i]]=arcalleles[sitekey,arcgroups[i]];
         split(arcalleles[sitekey,arcgroups[i]], arcgroupalleles, ",");
         for (a in arcgroupalleles) {
            if (arcgroupalleles[a] == sprimeallele) {
               groupstate[arcgroups[i]]="match";
            };
         };
      };
   };
   #Do sample-level matching:
   for (i=1; i<=n_arcs; i++) {
      indivstate[arcindivs[i]]="missing";
      if ((sitekey,arcindivs[i]) in arcalleles) {
         indivstate[arcindivs[i]]="mismatch";
         split(arcalleles[sitekey,arcindivs[i]], arcindivalleles, ",");
         for (a in arcindivalleles) {
            if (arcindivalleles[a] == sprimeallele) {
               indivstate[arcindivs[i]]="match";
            };
         };
      };
   };
#   Denisovan="missing";
#   Neandertal="missing";
#   Altai="missing";
#   Vindija="missing";
#   Chagyrskaya="missing";
#   Denisovanallelestr="Unk";
#   Neandertalallelestr="Unk";
#   if ((sitekey,"Denisovan") in arcalleles) {
#      Denisovan="mismatch";
#      Denisovanallelestr=arcalleles[sitekey,"Denisovan"];
#      split(arcalleles[sitekey,"Denisovan"], denalleles, ",");
#      for (a in denalleles) {
#         if (denalleles[a] == sprimeallele) {
#            Denisovan="match";
#         };
#      };
#   };
#   if ((sitekey,"Neandertal") in arcalleles) {
#      Neandertal="mismatch";
#      Neandertalallelestr=arcalleles[sitekey,"Neandertal"];
#      split(arcalleles[sitekey,"Neandertal"], neandalleles, ",");
#      for (a in neandalleles) {
#         if (neandalleles[a] == sprimeallele) {
#            Neandertal="match";
#         };
#      };
#   };
#   if ((sitekey,"AltaiNeandertal") in arcalleles) {
#      Altai="mismatch";
#      split(arcalleles[sitekey,"AltaiNeandertal"], altaialleles, ",");
#      for (a in altaialleles) {
#         if (altaialleles[a] == sprimeallele) {
#            Altai="match";
#         };
#      };
#   };
#   if ((sitekey,"Vindija33.19") in arcalleles) {
#      Vindija="mismatch";
#      split(arcalleles[sitekey,"Vindija33.19"], vindijaalleles, ",");
#      for (a in vindijaalleles) {
#         if (vindijaalleles[a] == sprimeallele) {
#            Vindija="match";
#         };
#      };
#   };
#   if ((sitekey,"Chagyrskaya-Phalanx") in arcalleles) {
#      Chagyrskaya="mismatch";
#      split(arcalleles[sitekey,"Chagyrskaya-Phalanx"], chagyrskayaalleles, ",");
#      for (a in chagyrskayaalleles) {
#         if (chagyrskayaalleles[a] == sprimeallele) {
#            Chagyrskaya="match";
#         };
#      };
#   };
   #Print the output line for a match, mismatch, or missing site:
   arcout=tractid;
   for (i=1; i<=n_arcgroups; i++) {
      arcout=arcout OFS groupstate[arcgroups[i]];
   };
   for (i=1; i<=n_arcgroups; i++) {
      arcout=arcout OFS groupallelestr[arcgroups[i]];
   };
   for (i=1; i<=n_arcs; i++) {
      arcout=arcout OFS indivstate[arcindivs[i]];
   };
#   print $0, tractid, Neandertal, Denisovan, Neandertalallelestr, Denisovanallelestr, Altai, Vindija, Chagyrskaya;
   print $0, arcout;
}
END{
   end=systime();
   print "Processing Sprime .score file took "end-f3start" seconds, average "(end-f3start)/n_score_records" seconds per record" > "/dev/stderr";
}
