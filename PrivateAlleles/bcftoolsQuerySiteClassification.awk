#!/bin/awk -f
#This script classifies sites (and selects them if requested)
# based on allele counts. The input is a TSV generated by
# bcftools query (possibly pre-filtered) using the output of
# bgt view (used to calculate population-specific allele counts).
#In general, we minimally require the AC* and AN*
# value columns (plus any reasonable key columns)
#
#Input arguments:
# valcols: comma-separated list of value columns
#          (default: AC,AN)
# exclude: comma-separated list of groups to indicate nonzero frequency
#          with an EXCLUDE_* filter
# singletons: flag to mark per-group singletons
#
# Defaults are based on running bgt and bcftools using:
# bgt view -s'region=="AFRICA"' -s'region=="AMERICA"' ... |
#  bcftools view -v snps -m 2 -M 2 -Ou |
#  bcftools query -H -f '%CHROM\t%POS\t%ID\t%REF\t%ALT\t%AC1\t%AN1\t...' - |
#  awk 'BEGIN{FS="\t";OFS=FS;}NR==1{$0=substr($0, 3); gsub(/\[[0-9]+\]/, "", $0);}{print;}'
# Note that -v snps -m 2 -M 2 is really just for testing biallelic SNPs,
#  but we should be compatible with other types.
#
#Convenience function for rounding to the nearest integer (biased rounding),
# used for computing allele counts from frequency and OBS_CT:
function round(x) {
   #Eliminate sign, get integer part, add one if needed, return the signed result:
   absval=x < 0 ? -x : x;
   ipart=int(absval);
   absround=absval-ipart < 0.5 ? ipart : ipart+1;
   rounded=x < 0 ? -absround : absround;
   return rounded;
}
BEGIN{
   FS="\t";
   OFS=FS;
   if (length(valcols) == 0) {
      valcols="AC,AN";
   };
   n_vals=split(valcols, vals, ",");
   if (valcols !~ "[,]?AC[,]?" || valcols !~ "[,]?AN[,]?") {
      print "Missing AC or AN from valcols list. Quitting." > "/dev/stderr";
      exit 1;
   };
   if (length(exclude) > 0) {
      n_exclude=split(exclude, excl, ",");
      for (i=1; i<=n_exclude; i++) {
         excluded[excl[i]]=i;
      };
   };
   n_pops=0;
   #Variable OTS defines the delimiter for filter tags:
   OTS=";";
}
#Parse the header line and check for value columns to identify
# groups:
NR==1{
   for (i=1; i<=NF; i++) {
      valcol=0;
      for (j=1; j<=n_vals; j++) {
         if ($i ~ "^"vals[j]) {
            #Skip the overall AC and AN columns:
            if ($i == vals[j]) {
               continue;
            };
            #Input should have the group index appended to the column name,
            # so strip the base column name to get the index:
            groupid=$i;
            sub(vals[j], "", groupid);
            if ((groupid,vals[j]) in cols) {
               print "Column "i" is redundant with column "cols[groupid,vals[j]]". Quitting." > "/dev/stderr";
               exit 3;
            };
            cols[groupid,vals[j]]=i;
            n_pops++;
            pops[groupid]=n_pops;
            valcol=1;
         };
      };
      if (!valcol) {
         cols[$i]=i;
         printf "%s"OFS, $i;
      };
   };
   if (!("REF" in cols) || !("ALT" in cols)) {
      print "Missing REF and/or ALT columns. Quitting." > "/dev/stderr";
      exit 4;
   };
   printf "tags";
   #This sort order will be important for iterating through columns:
   PROCINFO["sorted_in"]="@val_num_asc";
   for (j in pops) {
      printf OFS"freqs_%s", j;
      printf OFS"counts_%s", j;
   };
   printf "\n";
}
#For each site, classify and apply the filter(s):
NR>1{
   #Now we establish the alleles:
   n_alts=split($cols["ALT"], alleles, ",");
   alleles[0]=$cols["REF"];
   #Iterate through the populations to store the allele frequencies
   # and allele counts:
   for (i in pops) {
      if (((i,"AC") in cols) && ((i,"AN") in cols)) {
         n_altcounts=split($cols[i,"AC"], altcounts, ",");
         if (n_altcounts != n_alts) {
            print n_alts" ALT alleles, but "n_altcounts" ALT counts. Quitting." > "/dev/stderr";
            exit 6;
         };
         sumalts=0;
         #Iterate over the ALT alleles:
         for (j=1; j<=n_alts; j++) {
            counts[i,alleles[j]]=altcounts[j];
            if ($cols[i,"AN"] > 0) {
               freqs[i,alleles[j]]=counts[i,alleles[j]]/$cols[i,"AN"];
            } else {
               freqs[i,alleles[j]]="NA";
            };
            sumalts+=altcounts[j];
            metacounts[alleles[j]]+=counts[i,alleles[j]];
            metacounts["any"]+=counts[i,alleles[j]];
         };
         #Include the count and frequency of the REF allele:
         if ($cols[i,"AN"] > 0) {
            #We have to infer REF counts from AN-Sum(AC):
            counts[i,alleles[0]]=$cols[i,"AN"]-sumalts;
            freqs[i,alleles[0]]=counts[i,alleles[0]]/$cols[i,"AN"];
         } else {
            counts[i,alleles[0]]=0;
            freqs[i,alleles[0]]="NA";
         };
         metacounts[alleles[0]]+=counts[i,alleles[0]];
         metacounts["any"]+=counts[i,alleles[0]];
      } else {
         print "AC or AN missing for group "i". Quitting." > "/dev/stderr";
         exit 5;
      };
   };
   #If allele counts are requested, also calculate combined allele frequencies:
   #(I'm using "meta" here in the metapopulation sense, but it need not
   # strictly be a metapopulation scenario.)
   for (allele in metacounts) {
      if (allele != "any") {
         if (metacounts["any"] > 0) {
            metafreqs[allele]=metacounts[allele]/metacounts["any"];
         } else {
            print "Sum of allele counts across all populations is somehow "metacounts["any"]" for line "FNR > "/dev/stderr";
            metafreqs[allele]="NA";
         };
      };
   };
   #Iterate over the populations again to perform the filters:
   filters="";
   for (i=0; i<=n_alts; i++) {
      present[alleles[i]]=0;
      for (j in pops) {
         if (counts[j,alleles[i]] > 0) {
            present[alleles[i]]++;
            if (length(shared[alleles[i]]) > 0) {
               shared[alleles[i]]=shared[alleles[i]]","j;
            } else {
               shared[alleles[i]]=j;
            };
            if (length(exclude) > 0 && j in excluded) {
               filters=filters OTS "EXCLUDED_"j;
            };
         };
         if (length(singletons) > 0 && counts[j,alleles[i]] == 1) {
            filters=filters OTS "SINGLETON_"j"_"alleles[i];
         };
      };
      if (length(singletons) > 0 && metacounts[alleles[i]] == 1) {
         filters=filters OTS "SINGLETON_all_"alleles[i];
      };
      if (present[alleles[i]] > 1) {
         filters=filters OTS "SHARED_"shared[alleles[i]]"_"alleles[i];
      } else if (present[alleles[i]] == 1) {
         filters=filters OTS "PRIVATE_"shared[alleles[i]]"_"alleles[i];
      } else {
         #Slight bug if CHROM or POS is not present in input
         print "Somehow at site "$cols["CHROM"]":"$cols["POS"]" "alleles[i]" is present in "present[alleles[i]]" groups." > "/dev/stderr";
         filters=filters OTS "INVARIANT_!"alleles[i];
      };
   };
   #A bit of a hack, but substitute the first OTS with an OFS, since
   # we compose the filter tag string with an extra prefixed OTS:
   sub(OTS, OFS, filters);
   #Print out the key columns, plus any filter tags:
   firstout=1;
   for (i in cols) {
      n_keyparts=split(i, keyparts, SUBSEP);
#      print "debug: "n_keyparts, i;
      if (n_keyparts == 1) {
         if (firstout) {
            printf "%s", $cols[i];
            firstout=0;
         } else {
            printf OFS"%s", $cols[i];
         };
      };
   };
   printf "%s", filters;
   #Print out the per-group frequencies after the filter tags column:
   for (j in pops) {
      for (i=0; i<=n_alts; i++) {
         if (i == 0) {
            printf OFS"%f", freqs[j,alleles[i]];
         } else {
            printf ",%f", freqs[j,alleles[i]];
         };
      };
      for (i=0; i<=n_alts; i++) {
         if (i == 0) {
            printf OFS"%i", counts[j,alleles[i]];
         } else {
            printf ",%i", counts[j,alleles[i]];
         };
      };
   };
   printf "\n";
   #Clear out the arrays for the next SNP:
   delete counts;
   delete freqs;
   delete metacounts;
   delete metafreqs;
   delete present;
   delete shared;
}
